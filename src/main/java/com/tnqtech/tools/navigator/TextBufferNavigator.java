package com.tnqtech.tools.navigator;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Objects;
import java.util.Optional;

/**
 * Utility class that loads the plain text output generated by the extractor and
 * provides helpers to navigate through the text buffer.
 */
public final class TextBufferNavigator {

    private String buffer = "";
    private Path sourcePath;

    /**
     * Loads the content of the provided text file into memory.
     *
     * @param path the path to the text file produced by the extractor
     * @throws IOException if the file cannot be read
     */
    public void load(final Path path) throws IOException {
        Objects.requireNonNull(path, "path");
        buffer = Files.readString(path, StandardCharsets.UTF_8);
        sourcePath = path;
    }

    /**
     * Returns the path of the currently loaded file, if any.
     *
     * @return the source path or {@code null} when nothing has been loaded yet
     */
    public Path getSourcePath() {
        return sourcePath;
    }

    /**
     * Provides the full buffer content. Mainly useful for binding the text to
     * UI components.
     *
     * @return the loaded buffer as a {@link String}
     */
    public String getBuffer() {
        return buffer;
    }

    /**
     * Checks whether a buffer has been loaded.
     *
     * @return {@code true} if text data is available, otherwise {@code false}
     */
    public boolean isLoaded() {
        return sourcePath != null;
    }

    /**
     * Finds the first occurrence of the provided search text in the buffer and
     * returns its zero-based position.
     *
     * @param searchText the text to search for
     * @return an {@link Optional} containing the position if found
     */
    public Optional<Integer> findPosition(final String searchText) {
        Objects.requireNonNull(searchText, "searchText");
        if (buffer.isEmpty() || searchText.isEmpty()) {
            return Optional.empty();
        }
        final int index = buffer.indexOf(searchText);
        if (index < 0) {
            return Optional.empty();
        }
        return Optional.of(index);
    }

    /**
     * Extracts the token (word) located at the supplied buffer position. The
     * method walks backwards and forwards until it reaches a whitespace
     * boundary. If the position is outside the buffer an empty {@link Optional}
     * is returned.
     *
     * @param position the zero-based buffer position
     * @return an optional with the extracted selection description
     */
    public Optional<TextSelection> extractTokenAt(final int position) {
        if (buffer.isEmpty() || position < 0 || position >= buffer.length()) {
            return Optional.empty();
        }
        int start = position;
        int end = position;
        while (start > 0 && !Character.isWhitespace(buffer.charAt(start - 1))) {
            start--;
        }
        while (end < buffer.length() && !Character.isWhitespace(buffer.charAt(end))) {
            end++;
        }
        final String token = buffer.substring(start, end);
        return Optional.of(new TextSelection(start, end, token));
    }

    /**
     * Lightweight description of a selection inside the buffer.
     *
     * @param start the inclusive start index
     * @param end the exclusive end index
     * @param text the selected text
     */
    public record TextSelection(int start, int end, String text) {
    }
}
